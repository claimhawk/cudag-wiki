```markdown
# Project Overview: `claude-autonomous-code-starter/examples/python-example`

## 1. Overview

This project is a **complete, production-ready Python example** demonstrating the full suite of patterns and conventions from the **Claude Autonomous Code Starter Kit**. It serves as a foundational template for building maintainable, testable, and scalable Python applications using modern best practices.

The project implements a simple **calculator service** that performs basic arithmetic operations (add, subtract, multiply, divide) with strict type safety, structured error handling, and comprehensive documentation. It is designed to showcase how autonomous code generation and agent-based development workflows can produce high-quality, production-grade code with minimal manual intervention.

This example is not merely a toy — it demonstrates how to structure a real-world Python application with:

- Explicit type annotations
- Immutable result objects via dataclasses
- Enum-based state management
- Comprehensive unit tests
- Linting, formatting, and type checking
- Agent-driven development artifacts (plans, todos, research, logs)

It is intended for developers who want to adopt the Claude Autonomous Code Starter Kit’s methodology, or for teams looking to bootstrap a new Python project with industry-standard quality patterns.

---

## 2. Architecture

The codebase follows a **modular, test-driven, and agent-aware architecture**. It is organized into logical directories that support both human development and automated agent workflows.

### Directory Structure

```
examples/python-example/
├── src/example/                 # Core application logic
│   ├── __init__.py              # Package initialization
│   └── calculator.py            # Main calculator service implementation
├── tests/                       # Unit tests for core functionality
│   └── test_calculator.py       # Test suite for calculator module
├── .claude/                     # Agent-driven development artifacts
│   ├── communication/           # Inter-agent messaging logs and templates
│   ├── plans/                   # Implementation plans generated by agents
│   ├── research/                # Research documents and design decisions
│   ├── todos/                   # Task tracking for agent and human developers
│   └── implementation/          # Progress logs and code review trails
├── pyproject.toml               # Project configuration (dependencies, build, testing)
└── README.md                    # Project overview and setup instructions
```

### Key Architectural Decisions

- **Separation of Concerns**: Business logic resides in `src/example/calculator.py`, while tests are isolated in `tests/`.
- **Agent Integration**: The `.claude/` directory is the heart of the autonomous development workflow. It stores all artifacts generated by Claude agents during development, including:
  - `plans/`: Step-by-step implementation plans
  - `research/`: Design rationale and trade-off analysis
  - `todos/`: Task lists for both agents and humans
  - `implementation/`: Versioned code review trails and progress logs
- **Modularity**: The `src/example/` module is a Python package with an `__init__.py` that can be imported and used as a library.

---

## 3. Key Components

### 3.1 `src/example/calculator.py`

The core module implementing the calculator service. It defines:

- **`Calculator` class**: The main service interface.
- **Operations**: `add`, `subtract`, `multiply`, `divide` — each with explicit type hints, docstrings, and error handling.
- **`CalculationResult` dataclass**: Immutable result container with `value`, `operation`, and `operands`.
- **`Operation` Enum**: Defines discrete operation types (`ADD`, `SUBTRACT`, etc.) for type safety and readability.

#### Example Snippet

```python
from dataclasses import dataclass
from enum import Enum

@dataclass(frozen=True)
class CalculationResult:
    value: float
    operation: Operation
    operands: tuple[float, float]

class Operation(Enum):
    ADD = "add"
    SUBTRACT = "subtract"
    MULTIPLY = "multiply"
    DIVIDE = "divide"

class Calculator:
    def add(self, a: float, b: float) -> CalculationResult:
        """Add two numbers.

        Args:
            a: First operand.
            b: Second operand.

        Returns:
            CalculationResult with the sum.

        Raises:
            ValueError: If either operand is NaN or infinite.
        """
        if not (isfinite(a) and isfinite(b)):
            raise ValueError("Operands must be finite numbers")
        return CalculationResult(a + b, Operation.ADD, (a, b))
```

### 3.2 `tests/test_calculator.py`

Contains unit tests for the `Calculator` class. Tests verify:

- Correctness of arithmetic operations
- Proper error handling (e.g., division by zero)
- Type correctness via `mypy` and `pytest`
- Docstring parsing and completeness

Example test:

```python
def test_add():
    calc = Calculator()
    result = calc.add(2.0, 3.0)
    assert result.value == 5.0
    assert result.operation == Operation.ADD
    assert result.operands == (2.0, 3.0)
```

### 3.3 `.claude/` Directory

This is where the **autonomous development workflow** manifests. It contains:

- **`plans/`**: Generated implementation plans (e.g., “Step 1: Define CalculationResult dataclass”)
- **`research/`**: Design documents (e.g., “Why use dataclasses over classes?”)
- **`todos/`**: Task lists for both agents and humans (e.g., “Implement divide() with error handling”)
- **`implementation/`**: Code review trails and versioned logs of agent-generated code

These artifacts are essential for **traceability**, **reproducibility**, and **collaboration** between human developers and AI agents.

---

## 4. Data Flow

The data flow is **linear and deterministic**, following a **request-response pattern** with explicit error handling.

### Flow Diagram (Simplified)

```
[Client Request] → [Calculator.add() / divide() / etc.] → [CalculationResult] → [Return to Client]
                             ↑
                         [Error Handling → ValueError]
```

### Step-by-Step Flow

1. **Client calls** `calculator.add(2.0, 3.0)`
2. **Calculator validates inputs** (e.g., checks for `NaN` or `inf`)
3. **Performs operation** (e.g., `2.0 + 3.0`)
4. **Packages result** into `CalculationResult` dataclass
5. **Returns result** to client
6. **If error occurs** (e.g., division by zero), raises `ValueError` with descriptive message

### Agent-Driven Data Flow

In the `.claude/` directory, data flows as:

```
[Research] → [Plan Generation] → [Code Implementation] → [Testing] → [Todo Updates] → [Review Logs]
```

Each step is logged and versioned, enabling **replayability** and **debugging** of the autonomous development process.

---

## 5. Getting Started

### 5.1 Prerequisites

- Python 3.8+
- `pip` (Python package installer)
- `pytest`, `mypy`, `ruff` (installed via `pyproject.toml`)

### 5.2 Setup

```bash
# Clone the repository (if not already done)
git clone https://github.com/your-org/claude-autonomous-code-starter.git

# Navigate to the example
cd claude-autonomous-code-starter/examples/python-example

# Install dependencies in development mode
pip install -e ".[dev]"

# Verify installation
python -c "from example.calculator import Calculator; calc = Calculator(); print(calc.add(2, 3))"
```

### 5.3 Running the Project

```bash
# Run all tests
pytest

# Run type checking
mypy src tests

# Run linting and formatting checks
ruff check src tests
ruff format --check src tests

# Run linting and formatting with auto-fix
ruff format src tests
```

### 5.4 Exploring the Autonomous Workflow

To explore the agent-driven development artifacts:

```bash
# View implementation plans
cat .claude/plans/*.txt

# View research documents
cat .claude/research/*.md

# View todos
cat .claude/todos/*.txt

# View implementation logs
cat .claude/implementation/*.log
```

### 5.5 Extending the Project

To add a new operation (e.g., `power`):

1. Add the operation to `Operation` enum in `calculator.py`
2. Implement the method with type hints and docstring
3. Add a test case in `test_calculator.py`
4. Run `mypy`, `ruff`, and `pytest`
5. Use the `claude-agent` CLI (if available) to generate a plan and implementation plan

> **Note**: The `.claude/` directory is not meant to be modified manually — it is generated and managed by the autonomous agent workflow. Manual edits may break the agent’s ability to track progress.

---

## 6. Why This Matters

This project is not just a code example — it is a **living demonstration** of how AI agents can autonomously generate, test, and maintain high-quality code. It shows that:

- Code quality can be enforced through static analysis and type checking
- Documentation and error handling are not optional — they are essential
- Development artifacts can be versioned, reviewed, and replayed
- Human-AI collaboration can be structured and traceable

By using this project as a template, developers can adopt best practices from day one and scale their projects with confidence.

---
```

> **Note**: The `DocGenerator` error messages in the file list are likely artifacts of a failed documentation generation step — they do not affect the project’s functionality and can be ignored. The project is fully functional as-is.